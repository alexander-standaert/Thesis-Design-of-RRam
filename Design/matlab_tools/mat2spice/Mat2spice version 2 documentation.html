<!--
    This file was generated using MAT2SPICE v2.0, running on mat2spice2.m2html.
    
    If you want to update this file, please try to find the source file mat2spice2.m2html, and the files it depends on, such as toc.m2s.  It will be less work to update these since the files contain functions and macros that automatically take care of a lot of linking, header formatting, and the table of contents.  Also it will keep the M2HTML file up to date so that people who will edit it after you can also use the M2HTML file.
    
    After updating the M2HTML file, you can use MAT2SPICE to produce new HTML files.
    
    Original source file was written by Pieter Nuyts
    (pieter.nuyts@esat.kuleuven.be, pieter.nuyts@ieee.org)
    
    Version 2.0.1, July 2010
    
    (First two version numbers refer to Mat2spice version; third number is documentation version)
-->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<title>Mat2spice version 2 documentation</title>

</head>
<body><script src="Mat2spice%20version%202%20documentation_files/YouLoop_script.js" type="text/javascript"></script>

<a name="top">

<h1>Mat2spice version 2 documentation</h1>

<p>The <code>mat2spice</code> function preprocesses text files in which 
Matlab code is added to generate part of the text or code.  While 
intended primarily for preprocessing Spice and Spectre netlists, it can 
be used to generate any type of code.  It was e.g. used to generate part
 of the HTML code for this documentation.

</p><p>This document explains how to use <code>mat2spice</code>.  It 
assumes the reader has good knowledge of the Matlab programming 
language.  Although most examples use Spice as the target language, 
knowledge of Spice is not really needed to understand this document, 
since from a preprocessor point of view, the Spice code is just text 
that needs to be processed, regardless of what it means.


<!--===========================================================================================-->
 </p></a><h2><a name="top"></a><a href="#top" name="navigation">How to navigate through this document</a></h2> 

<p>Clicking the title of a section brings you back to the top of the 
document.  Clicking the title of a subsection brings you back to the top
 of the section, etc.

</p><p>You can use the table of contents below to go to the desired section.

<!--===========================================================================================-->
 </p><h2><a href="#top" name="toc">Table of contents</a></h2> 



<a href="#navigation">How to navigate through this document</a><br>
<a href="#toc">Table of contents</a><br>
<a href="#general_description">General description</a><br>
<a href="#calling_syntax">Calling syntax</a><br>
<a href="#basic_escaped_sequences">Basic types of escaped Matlab sequences</a><br>
&#8195;<a href="#inline_matlab_expression">Inline Matlab expression</a><br>
&#8195;<a href="#single_matlab_line">Single Matlab line</a><br>
&#8195;<a href="#matlab_comment_line">Matlab comment line</a><br>
&#8195;<a href="#inline_matlab_expression_short_syntax">Inline Matlab expression: short syntax</a><br>
&#8195;<a href="#matlab_code_block">Matlab code block</a><br>
&#8195;<a href="#bus">The <code>bus</code> function and the short bus notation</a><br>
&#8195;&#8195;<a href="#bus_function">The <code>bus</code> function</a><br>
&#8195;&#8195;<a href="#short_bus_notation">The short bus notation</a><br>
&#8195;<a href="#escaping_dollar_sign">Escaping the <code>$</code> sign</a><br>
<a href="#how_it_works">How it works</a><br>
<a href="#conditional_and_loop_constructs">Conditional and loop constructs</a><br>
<a href="#include_insert_import"><code>$include</code>, <code>$insert</code> and <code>$import</code></a><br>
&#8195;<a href="#include">The <code>$include</code> directive</a><br>
&#8195;<a href="#insert">The <code>$insert</code> directive</a><br>
&#8195;<a href="#import">The <code>$import</code> directive</a><br>
&#8195;<a href="#include_insert_import_summary">Summary</a><br>
<a href="#functions">Mat2spice functions</a><br>
&#8195;<a href="#helper_functions">Helper functions</a><br>
&#8195;&#8195;<a href="#m2s_getID"><code>m2s_getID</code></a><br>
&#8195;&#8195;<a href="#m2s_generateInstName"><code>m2s_generateInstName</code></a><br>
&#8195;&#8195;<a href="#m2s_getParsedText"><code>m2s_getParsedText</code></a><br>
<a href="#scope_of_variables">Scope of variables in <code>mat2spice</code></a><br>
&#8195;<a href="#global_variables">Global variables</a><br>
&#8195;<a href="#global_parameters">Global <code>mat2spice</code> parameters</a><br>
<a href="#error_handling">Error handling</a><br>
&#8195;<a href="#mat2spice_errors"><code>mat2spice</code> errors</a><br>
&#8195;<a href="#matlab_errors">Matlab errors</a><br>
&#8195;<a href="#errors_gen_code">Errors in generated code</a><br>
<a href="#known_issues">Known issues and limitations</a><br>
&#8195;<a href="#limitations">Limitations and technicalities</a><br>
&#8195;<a href="#bugs">Reported/suspected bugs</a><br>
<a href="#reporting_bugs">Reporting bugs</a><br>
<a href="#example_files">Example files</a><br>
<a href="#author">Author and version information</a><br>

<!--===========================================================================================-->
 <h2><a href="#top" name="general_description">General description</a></h2> 

<p>The <code>mat2spice</code> function is a code preprocessor.  An input
 file consists of any kind of code or ASCII text, in which Matlab 
commands and expressions occur, marked by escape characters.  Several 
types of escaped Matlab code can occur.  All escape sequences are based 
on the dollar sign (<code>$</code>).

</p><p><code>mat2spice</code> will create an output file in which the 
code from the input file is copied literally, except for any escaped 
Matlab code, which will be processed as described <a href="#basic_escaped_sequences">below</a>.

<!--===========================================================================================-->
 </p><h2><a href="#top" name="calling_syntax">Calling syntax</a></h2> 

<p> <code>mat2spice</code> is a Matlab function and can thus be called 
from the Matlab command line or from another Matlab function or script. 
 It is called using the syntax

</p><pre>mat2spice(inputfile, outputpath, ...)
</pre>


<p> <code>inputfile</code> is a <code>mat2spice</code> input file (see below for the syntax of such a file).  Its extension must start with <code>.m2</code> and add at least one letter.  The file may be specified as an absolute path, or relative to the current directory. 

</p><p> <code>outputpath</code> is the directory where the resulting 
output file will be generated.  This may also be either an absolute path
 or relative to the current directory.  If the output directory does not
 exist yet, it will be created.  If it does exist, files in it might be 
overwritten.  This is typically the
desired behaviour if the directory was created by a previous run of <code>mat2spice</code>, but using a directory
that also contains some non-autogenerated files is not a good idea.

</p><p>The main output file will have the same name as the input file, but with the <code>m2</code> removed from the extension.  For example, if the input is called <code>system.m2scs</code>, then the output file will be called <code>system.scs</code>.  There is one exception: if the extension is <code>.m2s</code> (which stands for <code>mat2spice</code>), the output file's extension will be <code>.sp</code>.

</p><p>The input file may include other <code>mat2spice</code> input files (i.e. also with an extension starting with <code>.m2</code>), which will also be processed.  Depending on which include directive is used (see <a href="#include_insert_import">below</a>),
 they may produce separate output files, which will normally be in some 
subdirectory of the output directory (although this is not guaranteed, 
see <a href="#include_second_argument">here</a> for more info on the second argument to the include directives).

</p><p>The input arguments <code>inputfile</code> and <code>outputpath</code> are mandatory.  After these two arguments, zero or more additional input arguments may be given.  These will be explained <a href="#global_parameters">later</a>. 

</p><p> <code>mat2spice</code> does not return any output arguments.

<!--===========================================================================================-->
 </p><h2><a href="#top" name="basic_escaped_sequences">Basic types of escaped Matlab sequences</a></h2> 

 <h3><a href="#basic_escaped_sequences" name="inline_matlab_expression">Inline Matlab expression</a></h3> 

<p>Inline Matlab expressions enclosed between <code>$&lt;</code> and <code>&gt;$</code> can occur anywhere in the code.  <code>mat2spice</code> will evaluate the expression and put the result where the escaped expression was.

For example, the code


</p><pre>* Number of bits
.param nbits = $&lt;2^5&gt;$
</pre>


will be expanded to


<pre>* Number of bits
.param nbits = 32
</pre>


The result of the expression may be any kind of number, logical, or 
array (in which case it will be converted to a string in some way) or it
 may be a string (in which case it will just be used as it is).

 <h3><a href="#basic_escaped_sequences" name="single_matlab_line">Single Matlab line</a></h3> 

<p>A line that starts with a <code>$</code> sign is interpreted as a full Matlab command line (except if the <code>$</code> sign is followed by <code>&lt;</code>, which denotes an <a href="#inline_matlab_expression">inline Matlab expression</a>).  The whole line, without the <code>$</code>,
 is executed like a normal Matlab line.  It does not produce any text in
 the output file.  If the Matlab command would normally print anything 
in the command window, this will still go to the command window, not to 
your output file.

For example,

</p><pre>* The line below will not show up in the output
$ nbits = 2^5;
* but it WILL have an effect

* Number of bits
.param nbits = $&lt;nbits&gt;$
</pre>


will be expanded to

<pre>* The line below will not show up in the output
* but it WILL have an effect

* Number of bits
.param nbits = 32
</pre>


<p>If you would forget the semicolon after <code>nbits = 2^5</code>, you would get the output

</p><pre>
nbits =

    32

</pre>


in your Matlab terminal, but the output file would still be unchanged.  
Note that there is no link whatsoever between the Spice parameter <code>nbits</code> and the Matlab variable with the same name.  For Matlab, the Spice parameter <code>nbits</code> is just a part of a string.

<p><i>Note that the <code>$</code> sign must really be the first character on the input line; any whitespace before it is not allowed.</i> After the <code>$</code> sign, any number of whitespaces (including 0) is allowed.

 </p><h3><a href="#basic_escaped_sequences" name="matlab_comment_line">Matlab comment line</a></h3> 

<p>A special case of a single Matlab line is a Matlab comment line, which starts with <code>$%</code> (Spaces between the <code>$</code> and the <code>%</code> sign are allowed).  Such a line is executed without the <code>$</code>, and since it then starts with a <code>%</code>, it is ignored.

</p><p>E.g., resuming the previous example, if the code had been

</p><pre>$% The line below will not show up in the output
$ nbits = 2^5;
$% but it WILL have an effect

* Number of bits
.param nbits = $&lt;nbits&gt;$
</pre>


the output would have been

<pre>
* Number of bits
.param nbits = 32
</pre>


i.e. the comment lines would no longer appear in the output file.  Since
 in the previous example, the line was a Spice comment line, this would 
not affect the actual Spice simulation, but it may be cleaner to use <code>$%</code> comments for comments that only make sense with the Matlab code present, and that are not useful in the Spice code.

<p> Furthermore, note that if the Spice comment contains a <code>$</code>
 sign, Matlab will consider it as an escape sign and try to expand it.  
This may be the desired behaviour, but if it is not, it can be avoided 
by using a <code>$%</code> comment.

 </p><h3><a href="#basic_escaped_sequences" name="inline_matlab_expression_short_syntax">Inline Matlab expression: short syntax</a></h3> 

<p>A shorter syntax exists for inline Matlab expressions: it consists of a <code>$</code>
 sign followed by an expression that does not contain any whitespace.  
Although it is most suitable for single-variable expressions (e.g. 
instead of <code>$&lt;nbits&gt;$</code>, you could as well write <code>$nbits</code>) or function calls (such as <code>$abs(i)</code>), it can be used for any expression as long as it does not contain any whitespace.  For example, <code>$-2*max(a,b)</code> is equivalent to <code>$&lt;-2*max(a,b)&gt;$</code>.

</p><p>Even though this syntax is convenient for very short expressions, it has to be used with care:
</p><ul>
    <li><b>No</b> whitespace at all is allowed within the expression, even if it is between brackets or within a string.  For example, <code>$max(a,b)</code> is correct code and is equivalent to <code>$&lt;max(a,b)&gt;$</code>, but in <code>$max(a, b)</code>, the expression will end at the whitespace and the code will be equivalent to <code>$&lt;max(a,&gt;$ b)</code>.  This will produce an error since <code>max(a,</code> is not a valid Matlab expression.
    
    </li><li>The expression is delimited <b>only</b> by whitespace or a newline character, not by any symbols or special characters.  For example, if <code>a</code> is equal to 5, then

<pre>.param nbits = $a
</pre>

    will be expanded to

<pre>.param nbits = 5
</pre>

    as expected.  However, the code

<pre>.param nbits = '3*$a'
</pre>

    will be expanded to

<pre>.param nbits = '3*5
</pre>

    i.e., the final quote will be missing.  This is because the evaluated Matlab expression is not <code>3</code> but <code>3'</code>, which is the complex-conjugate transpose of the matrix [3] and thus evaluates to 3.  This can be solved by writing either 

<pre>.param nbits = '3*$&lt;a&gt;$'
</pre>

    or

<pre>.param nbits = '3*$a '
</pre>

    
    </li><li>This syntax cannot be used at the very beginning of a line, since in this case, the <code>$</code> sign will be interpreted as the beginning of a Matlab line (as described <a href="#single_matlab_line">above</a>).  Thus, the code 

<pre>$ string = 'test';
 $string
</pre>

    (i.e. with a space before the second <code>$</code> sign) will be expanded to

<pre> test
</pre>

    whereas the code

<pre>$ string = 'test';
$string
</pre>

    will not produce any text in the output file but it will print

<pre>
string =

test

</pre>

    in the Matlab terminal.
    
    </li><li>It is also not possible to use this syntax if the character immediately after the <code>$</code> sign is a <code>{</code> or <code>[</code>, since <code>${</code> and <code>$[</code> start different types of escape sequences, as described in the following sections.
</li></ul>

In case of problems, a safe solution is to use the syntax with <code>$&lt;</code> and <code>&gt;$</code> as delimiters.

 <h3><a href="#basic_escaped_sequences" name="matlab_code_block">Matlab code block</a></h3> 

<p>A Matlab code block is delimited by <code>${</code> and <code>}$</code>.
  Each of these markers must be on a single line and cannot have any 
text before or after them, and no whitespace is allowed before the <code>$</code> sign or between the <code>$</code>
 sign and the brace.  All lines between them are interpreted as Matlab 
lines.  They will be executed but they will not produce any text in the 
output file.
  
</p><p>This is a more convenient alternative for the single Matlab line syntax (lines starting with <code>$</code>) in case you need a lot of subsequent Matlab lines.

</p><p>For example, the code

</p><pre>${
    % This is Matlab code
    a = 3;
    b = 5;
    d = a + 2*b;
}$
</pre>

is equivalent to

<pre>$ % This is Matlab code
$ a = 3;
$ b = 5;
$ d = a + 2*b;
</pre>


 <h3><a href="#basic_escaped_sequences" name="bus">The <code>bus</code> function and the short bus notation</a></h3> 
 <h4><a href="#bus" name="bus_function">The <code>bus</code> function</a></h4> 

<p>Large electronic circuits, especially digital ones, often include 
multibit buses, which have to be represented as separate nodes in Spice 
or Spectre.  In order to facilitate using buses, <code>mat2spice</code> supports the use of a <code>bus</code> function.

</p><p>Several implementations of such a function are possible, so you have to check the documentation of the <code>bus</code>
 function you use (or write one yourself), but the functionality should 
normally be something like this: The function's first argument is the 
name of the bus, and the next arguments are indices that specify which 
nodes should be created.  The function will then return a string 
containing all the generated nodes, separated by spaces.

</p><p>For example, the call

</p><pre>bus('in', 0:5)
</pre>

might return

<pre>in0 in1 in2 in3 in4 in5
</pre>

or

<pre>in_0 in_1 in_2 in_3 in_4 in_5
</pre>

or

<pre>in[0] in[1] in[2] in[3] in[4] in[5]
</pre>

or something similar, depending on which syntax you prefer and which syntax your simulator supports (e.g. the <code>[]</code> syntax may not be supported by all simulators).

<p>You may also want your <code>bus</code> function to support multi-dimensional buses, e.g.

</p><pre>bus('in', 0:5, 0:2)
</pre>

might return

<pre>in[0][0] in[0][1] in[0][2] in[1][0] in[1][1] in[1][2] in[2][0] in[2][1] in[2][2]
+ in[3][0] in[3][1] in[3][2] in[4][0] in[4][1] in[4][2] in[5][0] in[5][1] in[5][2]
</pre>

(Note that the <code>bus</code> function used here has a special feature
 that breaks a line if it becomes to long.  Apart from producing more 
readable Spice code, this may also be necessary because some simulators 
limit the maximum length of a line to e.g. 1024 characters).

<p>It may even be useful to support also string arguments, which could be passed e.g. in cell arrays: the code 

</p><pre>bus('in', {'', 'bar'}, 0:2)
</pre>

might return

<pre>in0 in1 in2 inbar0 inbar1 inbar2
</pre>


 <h4><a href="#bus" name="short_bus_notation">The short bus notation</a></h4> 

<p><code>mat2spice</code> provides a short notation for the <code>bus</code> function.  In order for this to work, the function must be called <code>bus</code> and be in a file called <code>bus.m</code>.  This file must be somewhere in your Matlab path.

</p><p>The short bus syntax looks like this:

</p><pre>in$[0:5][0:2]
</pre>

No spaces are allowed before the <code>$</code> sign, between the <code>$</code> and the first <code>[</code>, or between the first <code>]</code> and the second <code>[</code>.  The word before the <code>$</code>
 sign (i.e. starting from the last whitespace character or otherwise the
 beginning of the line) is considered to be the bus name (i.e. the first
 argument to <code>bus</code>).  Whatever is between a pair of square 
brackets is considered to be one of the following arguments, including 
the square brackets themselves (this usually does not make a 
difference).  Thus, the above code is equivalent to

<pre>$&lt;bus('in', [0:5], [0:2])&gt;$
</pre>


<p><code>mat2spice</code> does not impose any restrictions on the types 
of the arguments (they may be numbers, arrays, strings, cell arrays, 
objects, etc., and different arguments may have different types), nor on
 the number of arguments (you can add as many <code>[]</code> pairs as you want). It will just pass on all arguments to the <code>bus</code> function.  However, the <code>bus</code> function you use might not support all types or numbers of arguments.

</p><p>Note that a remark similar to the one made for the <a href="#inline_matlab_expression_short_syntax">short inline expression syntax</a> can be made here: The bus name is delimited on the left side <b>only</b>
 by whitespace, not by any other symbols.  This is normally not really a
 problem since node names are typically surrounded by spaces. 

 </p><h3><a href="#basic_escaped_sequences" name="escaping_dollar_sign">Escaping the <code>$</code> sign</a></h3> 

The dollar sign (<code>$</code>) can be escaped as <code>$$</code>.  However, the double <code>$</code> sign that occurs when two inline expressions occur directly next to each other (such as <code>$&lt;a&gt;$$&lt;b&gt;$</code>) will not be changed to one <code>$</code> sign.

<!--===========================================================================================-->
 <h2><a href="#top" name="how_it_works">How it works</a></h2> 

<p>While all the above features can perfectly be used without knowing how <code>mat2spice</code>
 works, for some of the more complex features, as well as for debugging,
 it may be practical to have some understanding of how it works.  This 
section is not intended to give a detailed and exact overview of the 
implementation of <code>mat2spice</code>; it only tries to give some basic understanding.

</p><p>The preprocessor basically works as follows:  It runs over the code and converts it to a Matlab file called <code>m2s_run.m</code> (it will normally be in the directory where the input file is).

</p><p>All Matlab lines and Matlab code blocks are simply copied into this Matlab-file (without the <code>$</code>, <code>${</code> and <code>}$</code> delimiters of course).

</p><p>All lines without any Matlab code are turned into calls to a Matlab function named <code>m2s_write</code> with the original code line as a string argument.  The function <code>m2s_write</code> basically writes its argument to a line in the output file.

</p><p>Lines with inline Matlab expressions are treated the same way, 
except that the inline expressions are first evaluated, converted to 
strings, and put at the right place in the string to be written.

</p><p>The result of this preprocessing is an executable M-file which contains
</p><ul>
    <li>function calls to <code>m2s_write</code>,
    </li><li>other Matlab statements resulting from Matlab lines or code blocks,
    </li><li>some other things such as function definitions, which serve to implement functionality that will be described later on.
</li></ul>
<code>mat2spice</code> then executes this M-file which produces the output file(s).

<!--===========================================================================================-->
 <h2><a href="#top" name="conditional_and_loop_constructs">Conditional and loop constructs</a></h2> 

<p>Most of the power of basic <code>mat2spice</code> code is in the fact that it allows conditional and loop constructs to be used.  

For example, you can write

</p><pre>$ if include_parasitics
Cpar in gnd 1f
$ end
</pre>

In this case, the <code>m2s_write</code> call (see <a href="#how_it_works">above</a> for more information on <code>m2s_write</code>) that will write the line <code>Cpar in gnd 1f</code> will be between the <code>if</code> and <code>end</code> statements and thus the line will appear in the output file only if the Matlab variable <code>include_parasitics</code> is true.  

<p>It is also possible to include Matlab lines within the <code>if</code> clause, which will also  be executed only if the condition is true.

</p><p>Clearly, the <code>if</code> statement can also be complemented with <code>elseif</code> and/or <code>else</code> statements.

</p><p>Switch statements can also be used: the following code selects 
whether an inverter, a NAND gate or a NOR gate should be used as an 
inverter, based on the Matlab variable <code>invtype</code>:

</p><pre>$ switch invtype
$  case 'inv'
Xinv in out vdd vss inv
$  case 'nand'
Xinv in in out vdd vss nand
$  case 'nor'
Xinv in in out vdd vss nor
$  otherwise
$      error('Invalid inverter type: %s', invtype);
$ end
</pre>


<p>You can also use <code>for</code> and <code>while</code> loops.  For example, the code

</p><pre>$ for i = 0:3
Xinv_$i node_$i node_$i+1 vdd vss inv size=$&lt;4^i&gt;$
$ end
</pre>

will produce

<pre>Xinv_0 node_0 node_1 vdd vss inv size=1
Xinv_1 node_1 node_2 vdd vss inv size=4
Xinv_2 node_2 node_3 vdd vss inv size=16
Xinv_3 node_3 node_4 vdd vss inv size=64
</pre>

which is a very powerful way to generate the large regular structures that are often used in digital hardware.

<p>Note that in most cases it is probably best to combine the use of <code>for</code> loops with the <code>bus</code> function, which is described <a href="#bus">here</a>.  This means it is better to write

</p><pre>$ for i = 0:3
Xinv$[i] node$[i] node$[i+1] vdd vss inv size=$&lt;4^i&gt;$
$ end
</pre>

instead of the code shown above.  Even though the <code>bus</code> function produces only one node here, this ensures the names of the node are always compatible with names generated with the <code>bus</code> function.  For example, it is very likely that the nodes <code>node_0</code> through <code>node_4</code> will be referenced somewhere using the bus function, i.e. as <code>node$[0:4]</code>.  If the <code>bus</code> function uses the underscore syntax, both fragments will work, but if you change the <code>bus</code> function to use e.g. the square bracket syntax, the upper code fragment will no longer work, while the lower one still will.
 
<p> In examples in the remaining part of this text, the <code>bus</code> function will be assumed to use the underscore syntax, i.e. <code>a$[2][3]</code> will produce <code>a_2_3</code>. 

<!--===========================================================================================-->
 </p><h2><a href="#top" name="include_insert_import"><code>$include</code>, <code>$insert</code> and <code>$import</code></a></h2> 

<p>Three keywords exist for including other input files: <code>$include</code>, <code>$insert</code> and <code>$import</code>.
  All of these will be referenced here as "include directives".  They 
all take a filename as argument and cause this file to be processed by <code>mat2spice</code> as well.

</p><p>All included files must have an extension starting with <code>.m2</code>, and if they produce an output file (this is the case if the <code>$include</code> directive is used) it will have the same name and another extension, in the same way as for the general input file (see <a href="#calling_syntax">above</a>).  If no extension is specified, <code>mat2spice</code> will add the default extension <code>.m2s</code>.
  (Note that if you have no extension but the filename contains a period
 for some reason, everything starting from the last period will be 
considered to be the extension).

</p><p>An include directive should look like this:

</p><pre>$include path/to/some/file.m2something second/argument
</pre>

with no space before or after the <code>$</code> sign (the <code>$</code> must be the first character of the line), and similar for <code>$insert</code> and <code>$import</code>.  More information about the second argument is given below.

<p>The file is specified as a path relative to the file where the 
include directive is.  In the remainder of this section, the file where 
the include directive is will be called the "parent file", and the file 
given as the argument will be called the "child file".  The <code>mat2spice</code>
 input files will then be called "parent input file" and "child input 
file" and the output files will be called "parent output file" and 
"child output file" (the latter does not always exist).

</p><p>Each file should be included or imported only once.  It is not 
allowed to include or import a file several times, even with different 
include directives (<code>$include</code> and <code>$import</code>) and/or from different parent files.

</p><p>It is not possible to conditionally include or import a file, e.g. from inside an <code>if</code> block.  This is because <code>mat2spice</code> first scans the whole file for include directives, and only afterwards processes the rest of the file.

</p><p>However, it is allowed to use the <code>$insert</code> directive several times, as well as inside conditional statements.  See <a href="#insert">below</a> for more information. 

 </p><h3><a href="#include_insert_import" name="include">The <code>$include</code> directive</a></h3> 

<p>The <code>$include</code> directive processes the child input file 
and writes the resulting output to a separate file (the child output 
file).  In the parent output file, <code>mat2spice</code> will put an 
appropriate include statement to include the child output file.  If the 
parent file is a Spice file, this will be a <code>.include</code> statement, unless the child file is a Spice VEC file.  In this case it will be a <code>.vec</code> statement.  If the parent file is a Spectre file, an <code>include</code> statement will be produced.

</p><p>The type of an input file is determined as follows:
</p><ul>
    <li>Files ending in <code>.m2s</code>, <code>.m2cir</code> or <code>.m2tit</code> are considered to be Spice files.
    </li><li>Files ending in <code>.m2scs</code> are considered to be Spectre files.
    </li><li>Files ending in <code>.m2vec</code> are considered to be Spice VEC files.
    </li><li>Files ending in <code>.m2mdl</code> are considered to be MDL files.  
    </li><li>All other files are considered to be "unknown" files. 
</li></ul>
Currently, unknown and MDL files are treated in exactly the same way as Spice files.

<p><a name="include_second_argument">By default, <code>mat2spice</code> 
will put the child output file at the same place relative to the parent 
output file as the child input file is relative to the parent input 
file.

</a></p><p><a name="include_second_argument">For example, if the parent input file is <code>~/m2s/parent.m2s</code> and the parent output file is <code>~/m2s/output/parent.sp</code> and the parent input file contains the directive

</a></p><pre><a name="include_second_argument">$include subdir/child.m2s
</a></pre><a name="include_second_argument">

then this means the child input file should be <code>~/m2s/subdir/child.m2s</code> and the child output file will be <code>~/m2s/output/subdir/child.m2s</code>.

<p>While this is mostly convenient, it may be quite annoying if the 
relative path contains ".." one or more times:  Suppose the directive 
was

</p><pre>$include ../some_far_away_library/child.m2s
</pre>

then the child input file should be <code>~/m2s/../some_far_away_library/child.m2s</code>, which is equal to <code>~/some_far_away_library/child.m2s</code>.  The child output file will now be <code>~/m2s/output/../some_far_away_library/child.m2s</code>, which is equal to <code>~/m2s/some_far_away_library/child.m2s</code>, so it is not in the output directory, which is mostly not desired.

<p>This can be solved using the second argument to <code>$include</code>.  This argument specifies a path for the child output file, relative to the parent output file.  Thus, by writing

</p><pre>$include ../some_far_away_library/child.m2s library
</pre>

the child output file will be <code>~/m2s/output/library/child.m2s</code>.  Any files included from the child input file will then use the directory <code>~/m2s/output/library/</code> as the starting point for their relative paths.

 </a><h3><a name="include_second_argument"></a><a href="#include_insert_import" name="insert">The <code>$insert</code> directive</a></h3> 

<p>The <code>$insert</code> directive also processes the child input 
file, but does not create a separate output file.  Instead, all output 
from the child input file is inserted in the parent output file, at the 
point where the <code>$insert</code> directive was given.

</p><p>If the <code>$insert</code> directive appears several times with the same filename, the <i>complete</i> output from this file will be inserted at all the points where the <code>$insert</code>
 directive appears.  This should only be done if the inserted file does 
not contain functions; if it does, inserting it several times would 
insert <i>all</i> of the generated subcircuits <i>every time,</i> which would result in Spice errors because several subcircuits with the same name are declared.

</p><p>Note that the output for the inserted file is re-generated everytime a <code>$insert</code> directive for the file is encountered.  If a global variable changes before the next <code>$insert</code> directive is encountered, the next <code>$insert</code>
 directive may produce different output.  Functions may exhibit 
unexpected behavior in such case, which is another reason not to use 
them with multiple <code>$insert</code> directives.

</p><p>Even though there is no child output file, the <code>$insert</code> directive does support the second argument.  This will only be used in case the child input file itself contains some <code>$include</code> statement.  Then the second argument will be used as a starting point for the resulting output file.
 
 </p><h3><a href="#include_insert_import" name="import">The <code>$import</code> directive</a></h3> 

<p>The <code>$import</code> directive also processes the child input file, but the output is not written to any file; it is just discarded.  Therefore, <code>$import</code> the import directive is only useful in combination with <a href="#functions">functions</a> using the <a href="#m2s_getParsedText"><code>m2s_getParsedText</code></a> helper function.  It also supports the second argument for the same reason mentioned above.

 </p><h3><a href="#include_insert_import" name="include_insert_import_summary">Summary</a></h3> 

<p>A file can be included in one of the following ways:
</p><ol>
    <li>It can be included <i>once</i> and <i>unconditionally</i> using the <code>$include</code> directive.
    </li><li>It can be included <i>once</i> and <i>unconditionally</i> using the <code>$import</code> directive.
    </li><li>If it contains functions, it can be included <i>once</i> and <i>unconditionally</i> using the <code>$insert</code> directive.
    </li><li>If it does not contain functions, it can be included <i>once or more</i>, possibly conditionally, using the <code>$insert</code> directive.
</li></ol>

<p>Combining different directives for a single file is never allowed.

<!--===========================================================================================-->
 </p><h2><a href="#top" name="functions">Mat2spice functions</a></h2> 

<p> <code>mat2spice</code> allows using special <code>mat2spice</code> functions to generate circuits or other code.  A <code>mat2spice</code> function is a Matlab function written on Matlab <code>$</code> lines and/or <code>${</code> <code>}$</code>
 code blocks, with Spice code in between.  Depending on the parameters 
passed to the function, it will generate different Spice code.

</p><p>Like a Matlab function, a <code>mat2spice</code> function may have any number of input and output arguments.

</p><p>Typically, a function will generate a Spice or Spectre subcircuit
 and return the subcircuit name (and possibly other information).  If 
called again with different parameters, it will generate a different 
version of the subcircuit.  However, if called again with the same 
parameters, it will recognize this and, even though it will still 
execute all of the code (in order to produce all the output arguments) 
and generate the Spice code again, it will not write the code to the 
output file anymore, since it already exists.

</p><p>Like normal Matlab functions, <code>mat2spice</code> functions start with the keyword <code>function</code> and end with <code>end</code>.  Any function declared in a <code>mat2spice</code> input file is a <code>mat2spice</code> function.  Note that the <code>function</code> and <code>end</code> keywords that delimit the function must be on a line starting with a <code>$</code> sign.  If they are within a <code>${</code> <code>}$</code> Matlab block, the function will not be recognized as a <code>mat2spice</code> function. 

</p><p>An example of a <code>mat2spice</code> function is shown below.  It creates a buffer consisting of <code>N</code> inverters, where the first has size 1 and every following inverter is a factor of <code>factor</code> larger than the previous one.
<a name="buffer_function_example">

</a></p><pre><a name="buffer_function_example">$ function name = buffer(N, factor)
$     name = sprintf('buffer_%i_%i', N, factor);
.subckt $name in out vdd vss

.connect in  n$[0]
.connect out n$[N-1]

$     for i = 0:N-1
Xinv n$[i] n$[i+1] vdd vss inv size=$&lt;factor^i&gt;$
$     end % for i

.ends

$ end % function


$% Test some function calls
Xbuf1 in1 out1 vdd vss $&lt;buffer(3, 3)&gt;$
Xbuf2 in2 out2 vdd vss $&lt;buffer(4, 2)&gt;$
Xbuf3 in3 out3 vdd vss $&lt;buffer(3, 3)&gt;$
</a></pre><a name="buffer_function_example">

This will result in the following code:

<pre>.subckt buffer_3_3 in out vdd vss

.connect in  n[0]
.connect out n[2]

Xinv n[0] n[1] vdd vss inv size=1
Xinv n[1] n[2] vdd vss inv size=3
Xinv n[2] n[3] vdd vss inv size=9

.ends

.subckt buffer_4_2 in out vdd vss

.connect in  n[0]
.connect out n[3]

Xinv n[0] n[1] vdd vss inv size=1
Xinv n[1] n[2] vdd vss inv size=2
Xinv n[2] n[3] vdd vss inv size=4
Xinv n[3] n[4] vdd vss inv size=8

.ends



Xbuf1 in1 out1 vdd vss buffer_3_3
Xbuf2 in2 out2 vdd vss buffer_4_2
Xbuf3 in3 out3 vdd vss buffer_3_3
</pre>


<p>There is no restriction on the type and number of input and output arguments of a <code>mat2spice</code>
 function.  It is also allowed to provide fewer input arguments than are
 present in the heading, on the condition that your function 
implementation supports this.

</p><p>Several ways exist to create the subcircuit name:
</p></a><ul><a name="buffer_function_example">
    <li>You can write your own code to generate a name as shown in the 
above example.  This has the advantage that you have all control over 
the name.  However, you have to guarantee yourself that every possible 
set of input parameters produces a unique subcircuit name.  Otherwise, 
the function may produce two different subcicuits with the same name, 
which will produce an error in the Spice simulator.
    </li></a><li><a name="buffer_function_example">You can use one of the helper functions </a><a href="#m2s_getID"><code>m2s_getID</code></a> or <a href="#m2s_generateInstName"><code>m2s_generateInstName</code></a>, which are explained below.
</li></ul>

<p><b>Some remarks:</b>
</p><ul>
   <!--NOT CORRECT <li>Even if a <code>mat2spice</code> function does not contain any non-Matlab lines, it still is not necessarily the same: the function will still store every set of inputs together with the resulting output.  While a Matlab function would recalculate its result every time it is called, the <code>mat2spice</code> function would look up the result in its lookup table of previous calls and return it.  This obviously takes more memory, and probably more CPU as well, since it has to search linearly through the lookup table, and since <code>mat2spice</code> functions are implemented as function handles, which are less efficient than functions.  Furthermore, a Matlab function does not necessarily give the same output every time it is called with the same inputs (it might e.g. have some memory or a random number generation inside).  This is not possible with <code>mat2spice</code> functions.  Thus, when writing a function without non-Matlab code, it is probably better to write it as a Matlab function, save it in an M-file and add it to the Matlab path so it can be called from anywhere.-->
    
    <li>While Matlab functions with string arguments can be called using command syntax (e.g. you can write <code>cd somedir</code> instead of <code>cd('somedir')</code>), this is not allowed for <code>mat2spice</code> functions.  This is because they are implemented as Matlab function handles, which do not support the command syntax.
    
    </li><li>Every <code>mat2spice</code> function stores a table of previous input arguments and the corresponding output arguments.  Everytime a <code>mat2spice</code>
 function is called, it will search this table for an occurence of the 
current input arguments.  The larger the table, the longer this will 
take.  If you use functions only for high-level circuits, this overhead 
will be negligible.  However, if you decide to turn every subcircuit 
into a function and replace all Spice parameters by <code>mat2spice</code> function arguments (which has certain advantages when mapping your netlist to a chip layout), you might e.g. have a function <code>inverter(size, pmos_nmos_ratio, n_fingers)</code>
 that will have a lot of entries in its table, one for each set of 
parameters that is used anywhere in your system.  In such cases it might
 be useful to pay some attention to performance.  For example, instead 
of writing

<pre>$ for i = 0:255
Xinv$[i] in$[i] inbar$[i] vdd vss $&lt;inverter(1, 2, 1)&gt;$
$ end
</pre>

    you could write

<pre>$ inv = inverter(1, 2, 1);
$ for i = 0:255
Xinv$[i] in$[i] inbar$[i] vdd vss $inv
$ end
</pre>

    which would reduce the number of function calls from 256 to 1.
    
    </li><li> <code>mat2spice</code> functions cannot be nested, i.e. it is not allowed to declare a <code>mat2spice</code> function within another <code>mat2spice</code> function.  They can, however, be used recursively, i.e. they are allowed to call themselves.
    
    </li><li><p>It is allowed to pass fewer arguments to a function than
 are present in the function header.  However, the function body must 
compensate for this by setting default values for all uninitialised 
parameters, even if they will never be used.  The reason for this is 
that <code>mat2spice</code> needs all argument values in order to 
determine whether it should produce new output text or just return 
without writing any text. 
    
    </p><p>All arguments must be initialised <i>before</i> any non-Matlab line occurs, and before any of the helper functions presented <a href="#helper_functions">below</a> is called.  A non-Matlab line is any line that does not start with a <code>$</code> and is not between <code>${</code> and <code>}$</code>.  Note that this also includes blank lines.
       
    </p><p>For example, if you declare a function

</p><pre>$ function myfunc(a, b)
</pre>

    you can call it as <code>myfunc(3)</code> on the condition that the function body checks that <code>b</code> has not been initialised (you can use <code>nargin</code> to check the number of arguments) and assigns a value to it.  The code could for example look like this:

<pre>$ function myfunc(a, b)
$    if nargin &lt; 2
$        b = 0;
$    end
$% Spice code or blank lines are not allowed before this line

&lt;subcircuit implementation&gt;

$ end
</pre>

    <p>Because every argument always needs to be initialised, it is not allowed to use <code>varargin</code>.
</p></li></ul>

 <h3><a href="#functions" name="helper_functions">Helper functions</a></h3> 

<p>Within each <code>mat2spice</code> function, three helper functions are automatically defined: <a href="#m2s_getID"><code>m2s_getID</code></a>, <a href="#m2s_generateInstName"><code>m2s_generateInstName</code></a> and <a href="#m2s_getParsedText"><code>m2s_getParsedText</code></a>, which are described below.  None of them takes any arguments.

 </p><h4><a href="#helper_functions" name="m2s_getID"><code>m2s_getID</code></a></h4> 

<p>The <code>m2s_getID</code> function returns a positive integer number that is based on the values of the parameters that were passed to the <code>mat2spice</code> function in which <code>m2s_getID</code>
 is called.  This helper function guarantees that for the same set of 
parameter values, the same number will always be returned, and that for 
two different sets of parameter values, a different number will always 
be returned.  Thus, this number can be used to generate a unique and 
reproducible subcircuit name for each subcircuit the function produces.

</p><p>No other guarantees are given about the number returned.  
Furthermore, it is only guaranteed that a certain set of parameter 
values will produce the same number <i>within a single run of <code>mat2spice</code></i>.  When you run <code>mat2spice</code>
 again after making some modifications to your code, the same set of 
parameter values may result in a different value, even if you did not 
change anything to the function itself.

</p><p>For example: the <code>buffer</code> function shown <a href="#buffer_function_example">above</a> can be rewritten as follows (the only line that was changed is the second line):
<a name="buffer_function_example_m2s_getID">

</a></p><pre><a name="buffer_function_example_m2s_getID">$ function name = buffer(N, factor)
$     name = sprintf('buffer_%i', m2s_getID);
.subckt $name in out vdd vss

.connect in  n$[0]
.connect out n$[N-1]

$     for i = 0:N-1
Xinv n$[i] n$[i+1] vdd vss inv size=$&lt;factor^i&gt;$
$     end % for i

.ends

$ end % function


$% Test some function calls
buffer(3, 3)
buffer(4, 2)
buffer(3, 3)
</a></pre><a name="buffer_function_example_m2s_getID">


<p>Since <code>m2s_getID</code> needs to know the values of all parameters, it is required that all parameters have been initialised at the time <code>m2s_getID</code> is called.  For example, in the above function you might want to introduce the option to pass only the first argument (<code>N</code>) and have the <code>factor</code> argument default to 4.  This is allowed, but in this case, the default value must be assigned to <code>factor</code> <i>before</i> <code>m2s_getID</code> is called.

 </p></a><h4><a name="buffer_function_example_m2s_getID"></a><a href="#helper_functions" name="m2s_generateInstName"><code>m2s_generateInstName</code></a></h4> 

<p>The <code>m2s_generateInstName</code> function generates a complete subcircuit name by starting from the function name (<code>buffer</code> in the <a href="#buffer_function_example_m2s_getID">above</a> example) and adding an underscore (<code>_</code>) and the number returned by <a href="#m2s_getID"><code>m2s_getID</code></a>.

</p><p>For example, in the <a href="#buffer_function_example_m2s_getID">above</a> example, the line

</p><pre>$     name = sprintf('buffer_%i', m2s_getID);
</pre>

could be rewritten as

<pre>$     name = m2s_generateInstName;
</pre>


<p>Since <code>m2s_generateInstName</code> calls <code>m2s_getID</code> it can also be called only after all parameters have been initialised.

 </p><h4><a href="#helper_functions" name="m2s_getParsedText"><code>m2s_getParsedText</code></a></h4> 

<p>The <code>m2s_getParsedText</code> function returns all the text that was produced during the run of the function.  In the <a href="#buffer_function_example_m2s_getID">above</a> example, this would be the buffer subcircuit that was generated.
 
</p><p>This function is useful mainly when a file is included using the <code>$import</code> directive.  In this case, the generated code is not written to any output file, but can be accessed using <code>m2s_getParsedText</code> in order to be e.g. returned by the <code>mat2spice</code> function.  Note that in this case the <code>m2s_getParsedText</code>
 function should normally be called after the last non-Matlab line, 
since any non-Matlab lines that appear after this call are just 
discarded.

<!--===========================================================================================-->
 </p><h2><a href="#top" name="scope_of_variables">Scope of variables in <code>mat2spice</code></a></h2> 

<p>Each <code>mat2spice</code> input file has its own scope, i.e. all variables declared in a file are accessible from within that file only.

</p><p>Each <code>mat2spice</code> function has its own scope, but also shares the scope of the file in which the function is defined. This means that 
</p><ul>
    <li>all variables declared inside a <code>mat2spice</code> function are accessible only from within that function,
    </li><li>all variables declared in a file but outside any function, can also be accessed from within all <code>mat2spice</code> functions in that file.  This can be convenient to implement an instance count:

<pre>$ instcount = 0;

$ function name=createInst(param)
$     name = m2s_generateInstName;

&lt;instance body&gt;

$     instcount = instcount+1;
$ end

$ function out = getInstCount()
$     out = instcount;
$ end

Xinst1 n1 n2 $createInst(1)
Xinst2 n2 n3 $createInst(2)
Xinst3 n3 n4 $createInst(3)

* this circuit has generated $getInstCount() instances
</pre>

</li></ul>

 <h3><a href="#scope_of_variables" name="global_variables">Global variables</a></h3> 

<p>If you want a variable to be accessible from any <code>mat2spice</code> file, you can declare it global using the Matlab keyword <code>global</code>.  However, it is recommended not to use this approach, but instead pass global parameters externally with the <code>mat2spice</code> function call, as explained <a href="#global_parameters">below</a>.
 
 </p><h3><a href="#scope_of_variables" name="global_parameters">Global <code>mat2spice</code> parameters</a></h3> 

<p>Apart from the first two arguments, which are mandatory (see <a href="#calling_syntax">above</a> for their meaning), <code>mat2spice</code>
 supports an arbitrary number of additional arguments.  Each of these 
arguments will be turned into a variable that will be readable and 
writable from any <code>mat2spice</code> input file.  The variables will have the same names they had in the scope that <code>mat2spice</code> was called from.  For example, if you write

</p><pre>a = 3;

mat2spice('inputfile.m2s', 'outputpath/', a);
</pre>

then in every <code>mat2spice</code> input file, a variable <code>a</code> will exist with value 3.  If you would have written

<pre>b = 3;

mat2spice('inputfile.m2s', 'outputpath/', b);
</pre>

then the variable will be called <code>b</code>.  Writing

<pre>mat2spice('inputfile.m2s', 'outputpath/', 3);
</pre>

will produce an error since <code>mat2spice</code> cannot determine a name for the variable.

<p>Obviously, it is a good idea to use nontrivial names for this kind of
 variables in order to avoid overwriting them by accident (e.g. by 
writing <code>$for a = 0:5; ...</code>).  A good way to do this is to group parameters into one or more structures.

</p><p>Be careful to change global variables in mat2spice input files, 
this could lead sometimes to unexpected results when a forgotten file 
alters a certain value.  Furthermore, the order in which the Matlab 
statements are executed depends on the order of the include directives 
and may therefore be unclear, especially when using <code>$insert</code> directives, since they can occur several times and produce different output if a global variable was changed between to <code>$insert</code> directives.


<!--===========================================================================================-->
 </p><h2><a href="#top" name="error_handling">Error handling</a></h2> 

 <h3><a href="#error_handling" name="mat2spice_errors"><code>mat2spice</code> errors</a></h3> 

<p><code>mat2spice</code> errors can occur e.g. if wrong arguments are passed to the <code>mat2spice</code> function, or if an included file cannot be found.  They are relatively rare and will be reported by <code>mat2spice</code> like any other Matlab function may report errors.

 </p><h3><a href="#error_handling" name="matlab_errors">Matlab errors</a></h3> 

<p>Matlab errors are errors in the Matlab code that is in one of your 
input files.  Any code (whether correct or not) will be copied by <code>mat2spice</code> into the <code>m2s_run.m</code> file (see the <a href="#how_it_works">How it works</a> section for more information on this file).  Errors in the Matlab code will only occur at the time Matlab executes the <code>m2s_run.m</code> file.

</p><p>Without any special measures, Matlab would just report an error on some line in the <code>m2s_run.m</code>
 file.  This is mostly an extremely long file (since it contains all 
your input files plus some extra code) and often contains very 
hard-to-read code, which may make it hard to find the error.

</p><p>In order to solve this, <code>mat2spice</code> will catch the error and report it with some extra information, showing not only the line in the <code>m2s_run.m</code> file where the error occurred, but also the corresponding line in one of the <code>mat2spice</code>
 input files.  In most cases, it will be easier to go to the mentioned 
line in the input file (if you use Matlab's graphical environment, you 
can do this by clicking on the error message).

</p><p><font size="2">(This error handling is the reason that on some places in the <code>m2s_run.m</code> file there is lots of code on one single line: by ensuring that each line in <code>m2s_run.m</code> corresponds to exactly one line in one of the input files, <code>mat2spice</code> is always able to find on which line the error occurred).</font>

</p><p>Some syntax errors, however, such as e.g. forgetting and <code>end</code> or forgetting to close a bracket or a string etc., may mess up the Matlab code in <code>m2s_run.m</code> so much that it is no longer clear on which line the error is exactly.  In this case, <code>mat2spice</code> might not be able to show the correct line.  In order to solve this kind of errors, it might be necessary to look into <code>m2s_run.m</code>.

 </p><h3><a href="#error_handling" name="errors_gen_code">Errors in generated code</a></h3> 

<p>Errors in your generated code will of course not be signalled by <code>mat2spice</code>, since it is only a preprocessor; it does not understand the code it generates.

</p><p>Typically, you will write a script that first runs <code>mat2spice</code> and then runs e.g. a Spice simulator on the produced code.  Spice errors will then be reported by the Spice simulator after <code>mat2spice</code> finishes.

<!--===========================================================================================-->
 </p><h2><a href="#top" name="known_issues">Known issues and limitations</a></h2> 

 <h3><a href="#known_issues" name="limitations">Limitations and technicalities</a></h3> 

<ul>
    <li><code>mat2spice</code> stores all of its working data into a struct variable named <code>m2s</code>.  Because of technical reasons, this variable can be read and written from any <code>mat2spice</code> input file.
    <ul>
        <li>Do not change anything to this variable unless you know what you are doing.
        </li><li>Do not try to create local variables called <code>m2s</code>.  Instead of creating a new variable, you will just change <code>m2s</code>.
        </li><li>Do not create functions called <code>m2s</code> as this may conflict with the <code>m2s</code> variable.
        </li><li><code>mat2spice</code> also defines a lot of functions whose names start with <code>m2s</code>.  Therefore, you should avoid creating any variables or functions starting with <code>m2s</code> in order to avoid conflicts. 
    </li></ul>
    
    </li><li>All <code>mat2spice</code> input files that are included in a single <code>mat2spice</code> run must have different names, even if they are in different directories and/or have different extensions.  This is because <code>mat2spice</code> creates a function for each input file, and this function's name does not include the path or extension of the file.
    
    </li><li>As mentioned before, the lines

<pre>$alfa
</pre>

    (with the <code>$</code> as the first character of the line) and

<pre> $alfa
</pre>

    (with a space before the dollar) are not the same: the first is a <a href="#single_matlab_line">single Matlab line</a>, while the second is the <a href="#inline_matlab_expression_short_syntax">short notation for an inline Matlab expression</a> that happens to be at the beginning of a line.
    
    </li><li><p><code>mat2spice</code> uses a lot of regular expressions
 to recognize escape sequences.  Therefore it may get confused if 
sequences occur that look like escape sequences but should not be 
interpreted that way in the given context.  For example, the inline 
expression <code>$&lt;'&gt;$'&gt;$</code>, which is expected to result in the text <code>&gt;$</code>, will be parsed wrongly since the regular expression searching for code included between <code>$&lt;</code> and <code>&gt;$</code> will match with the text <code>$&lt;'&gt;$</code> and ignore what comes next.  Thus a Matlab error will be given since <code>'</code> is not a valid Matlab expression.
    </p><p>Depending on the specific situation, several ways exist to solve this kind of problems:
    </p><ul>
        <li>Store the string you need in a variable first.  This can be 
done in a Matlab block or on a single Matlab line.  Since these are much
 easier to parse, this will probably not cause any problems.  For 
example, in this case, you could write

<pre>$ gtdollar = '&gt;$';
</pre>

        and then just use <code>$&lt;gtdollar&gt;$</code> or <code><code>$</code>gtdollar</code> instead of <code>$&lt;'&gt;$'&gt;$</code>.
        
        </li><li>Split up the string that causes the problems into 
different strings that you concatenate using array notation in Matlab, 
or by just putting several inline Matlab expressions next to each other.
  In our example, the inline expression <code>$&lt;'&gt;$'&gt;$</code> would then be replaced by either <code>$&lt;['&gt;','$']&gt;$</code> or <code>$&lt;'&gt;'&gt;$$&lt;'$'&gt;$</code>.
        
        </li><li>If the dollar sign still causes troubles, it may be 
good to know that its ASCII value is 36 (decimal notation) so the Matlab
 expression <code>char(36)</code> is equivalent to the string <code>'$'</code>.  This expression will never raise any parsing problems since it does not contain any escape characters.
    </li></ul>
</li></ul>

 <h3><a href="#known_issues" name="bugs">Reported/suspected bugs</a></h3> 

<ul>
    <li>It has been found that a percent sign (<code>%</code>) on a 
non-Matlab line sometimes causes the parsing of the file in question to 
end at the point where the percent sign is.  The percent sign and all 
following text are discarded.  However, in the vast majority of cases, 
percent signs do not cause any troubles.  Thus far it has not been 
possible to deliberately trigger this bug. If it occurs, it can probably
 be solved by escaping the character as e.g. <code><code>$&lt;</code>'%'<code>&gt;$</code></code>. In this case the <code>%</code>
 sign occurs within a Matlab expressions and such cases are not known to
 ever produce any problems. If this still doesn't work, you can write <code><code>$&lt;</code>char(37)<code>&gt;$</code></code>, which should definitely produce the % sign. 
</li></ul>

<!--
known issues:
dollar_include requires extension if filename contains period
-->

<!--===========================================================================================-->
 <h2><a href="#top" name="reporting_bugs">Reporting bugs</a></h2> 

<p>Bug reports can be sent to <a href="mailto:daniels.jorg@gmail.com">daniels.jorg@gmail.com</a>.

</p><p>If the bug cannot be found and/or solved directly, please also put it in the list of known bugs on the <a href="https://securehomes.esat.kuleuven.be/%7Emicwiki/wiki/Software/Mat2spice">Micas wiki</a> (if you are working at Micas).

<!--===========================================================================================-->
 </p><h2><a href="#top" name="example_files">Example files</a></h2> 

<ul>
    <li>This file was generated from the files <a href="http://homes.esat.kuleuven.be/%7Epnuyts/mat2spice2_docs/mat2spice2.m2html"><code>mat2spice2.m2html</code></a> (the top file), <a href="http://homes.esat.kuleuven.be/%7Epnuyts/mat2spice2_docs/toc.m2s"><code>toc.m2s</code></a> and <a href="http://homes.esat.kuleuven.be/%7Epnuyts/mat2spice2_docs/toc_helper.m2s"><code>toc_helper.m2s</code></a>.  While these are not typical Spice-related <code>mat2spice</code> files, they can be interesting as an example of what else <code>mat2spice</code> can do.  If desired, you can also have a look at the generated Matlab-script <a href="http://homes.esat.kuleuven.be/%7Epnuyts/mat2spice2_docs/m2s_run.m"><code>m2s_run.m</code></a>, although this is probably not very informative.
    
    </li><li>More example files can be found on the <a href="https://securehomes.esat.kuleuven.be/%7Emicwiki/wiki/Software/Mat2spice">Micas wiki</a>.
</li></ul>

<!--===========================================================================================-->
 <h2><a href="#top" name="author">Author and version information</a></h2> 

Code written by Jorg Daniels
<ul>
    <li>First version created September 15, 2006
    </li><li>Latest revision of version 2: July 2010
    </li><li>License information can be found in the source code file.  Extracted from there on Jul 26, 2010:
<pre>%  This software is free to use and distribute. 
%  Bug reports go to daniels.jorg@gmail.com.
%  You are free to modify the source code but I appreciate if you send me a 
%  copy of any significant modifications or additions to the code.
%  This text must be included in all copies or future versions.
</pre>
</li></ul>
<par>

<p>Documentation for version 2.0 written by Pieter Nuyts, July 2010.

</p><p>Changelog of the code:
<table cellspacing="20">
    <tbody><tr><td>v1.0</td><td>15/09/06</td><td>by Jorg Daniels</td><td>first version</td></tr>
    <tr><td>v1.5</td><td>01/02/08</td><td>by Jorg Daniels</td><td>included error handling</td></tr>
    <tr><td>v2.0</td><td>26/07/10</td><td>by Jorg Daniels</td><td>Major 
revision.  Several bugfixes and new features such as separate workspaces
 for each m2s file, support for matlab functions in m2s-style, added 
syntax such as the <code>$var</code> short notation, bus notation,...</td></tr>
    <tr><td>v2.0.1</td><td>03/01/11</td><td>by Pieter Nuyts</td><td>(a) Replaced opening Matlab block delimiter '<code>{$</code>' with '<code>${</code>' in two error messages <br> (b) If argument <code>outpath</code> starts with <code>/</code> or <code>~</code>, <code>'./'</code> is no longer prepended.</td></tr>
</tbody></table>




</p></par></body></html>